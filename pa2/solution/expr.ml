(*
 * expr.ml
 * cse130
 * based on code by Chris Stone
 *)

(* Please do not modify the names or types of any of the following
 * type constructors, or predefined functions, unless EXPLICITLY
 * asked to. You will loose points if you do.
 *)


(*Dataype expr *)

type expr = 
    VarX
  | VarY
  | Sine     of expr
  | Cosine   of expr
  | Average  of expr * expr
  | Times    of expr * expr
  | Thresh   of expr * expr * expr * expr
  | Add      of expr * expr
  | Sub      of expr	
(* expToString: expr -> string
    Converts a given expression into a string equivalent.
    Implementation: Pattern matching is used to determine the function.
                    A string that follows the usual mathematical format is
                    generated by passing in nested functions that are deciphered
                    through recursion.
*)
let rec exprToString e =
    match e with
    | VarX -> "x"
    | VarY -> "y"
    | Sine a1 -> "sin(pi*"^(exprToString a1)^")"
    | Cosine a1 -> "cos(pi*"^(exprToString a1)^")"
    | Average (a1,a2) -> "(("^(exprToString a1)^"+"^(exprToString a2)^")/2)"
    | Times (a1,a2) -> (exprToString a1)^"*"^(exprToString a2) 
    | Thresh (a1,a2,a3,a4) -> "("^(exprToString a1)^"<"^(exprToString a2)^"?"^(exprToString a3)^":"^(exprToString a4)^")"
    | Add (a1,a2) -> "(("^(exprToString a1)^"+"^(exprToString a2)^")/5)"
    | Sub a1 -> "sin(cos("^(exprToString a1)^"))";;

(* build functions:
     Use these helper functions to generate elements of the expr
     datatype rather than using the constructors directly.  This
     provides a little more modularity in the design of your program *)

let buildX()                       = VarX
let buildY()                       = VarY
let buildSine(e)                   = Sine(e)
let buildCosine(e)                 = Cosine(e)
let buildAverage(e1,e2)            = Average(e1,e2)
let buildTimes(e1,e2)              = Times(e1,e2)
let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)


let pi = 4.0 *. atan 1.0

(* eval: expr * float * float -> float
    Uses an expr datatype to calculate the expression. It takes in two floats,
    which are represented by VarX and VarY. 
    Implementation: Pattern matching is used to determine the operators and expressions
                   being calculated. Through built-in operators and recursion, every 
                   expression is calculated into a float.
*)
let rec eval (e,x,y) = 
   match e with
    | VarX -> x
    | VarY -> y
    | Sine a1 -> sin(pi*.(eval(a1,x,y)))
    | Cosine a1 -> cos(pi*.(eval(a1,x,y)))
    | Average (a1,a2) -> (((eval(a1,x,y))+.(eval(a2,x,y)))/.2.0)
    | Times (a1,a2) -> (eval(a1,x,y))*.(eval(a2,x,y)) 
    | Thresh (a1,a2,a3,a4) -> if (eval(a1,x,y))<(eval(a2,x,y)) then (eval(a3,x,y)) else (eval(a4,x,y))
    | Add (a1,a2) -> (((eval(a1,x,y))+.(eval(a2,x,y)))/.5.0)
    | Sub a1 ->  cos(pi*.(sin(pi*.(eval(a1,x,y)))));;  

(* (eval_fn e (x,y)) evaluates the expression e at the point (x,y) and then
 * verifies that the result is between -1 and 1.  If it is, the result is returned.  
 * Otherwise, an exception is raised.
 *)
let eval_fn e (x,y) = 
  let rv = eval (e,x,y) in
  assert (-1.0 <= rv && rv <= 1.0);
  rv

let sampleExpr =
      buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(
      buildX()),buildTimes(buildCosine (buildCosine (buildAverage
      (buildTimes (buildY(),buildY()),buildCosine (buildX())))),
      buildCosine (buildTimes (buildSine (buildCosine
      (buildY())),buildAverage (buildSine (buildX()), buildTimes
      (buildX(),buildX()))))))),buildY())))

let sampleExpr2 =
  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))


(************** Add Testing Code Here ***************)
